begin public class LinkedList
	begin documentation
		This is an implementation of a "linked list"-like data structure which is a simple
		recursive data structure with some example methods. This is just example code, and
		probably should not be used in practice, because it is a highly inefficient data
		structure. This is an example documentation block, to be used similarly to docstrings
		in Python.
	end documentation
	
	begin comment
		This is an example block-style comment, like /* */ in C. It will be attached to the
		class it is in in the AST.
	end comment

	public class Terminator isa Object 
		# A complete class definition! 
		# Terminator is a subclass of Object, overriding nothing and adding nothing.
		# These comments will all be concatentated and attached to the preceding line (as if # were a
		# left-associative operator) in the AST.
	
	public class Link := (Terminator or LinkedList) 
		# Build a tagged union class by operator
		# immutable (the assignment is done at compile time)

	Object this.data 
		# "this." indicates it is a instance attribute not a class namespace member
		# all attributes default to a private, immutable (single-assignment per instance) attribute
	
	field Link this.next 
		# field indicates that it is a mutable instance attribute 

	begin public constructor new
		(Object initialData) to this 
			# to this indicates it returns an instance
		next := Terminator   
			# Immutable attributes that weren't initialized at
			# compile time must be initialized in the constructor
		data := initialData
	end constructor

	begin public constructor new
		(Object initialData, LinkedList initialNext) to this
		next := initialNext
		data := initialData
	end constructor
	
	begin public accessor this(Natural index) to (Object return)
		# this() defines behaviour when used like an array, similarly to overriding __getitem__
		# in Python. this[] may also be used with no change in semantics.
		if index == 0 # to prevent confusion there is no = operator
			return := data # := operator for single-assignment
		else
			return := next(index - 1)
		end if
	end function

	begin public function this.insertBefore(Object newData) to this
		# "this to this" indicates we modify this
		# "this.functionName" indicates an instance function not a class function
		this <- LinkedList.new(initialData : newData, initialNext : this)
		# functions with more than one argument (apart from "this") must be specified by keyword
	end function

	begin public function this.insertAfter(Object newData) to this
		next.insertBefore(newData) # because insertBefore modifies this, it can only be called on mutable
			# variables or fields
		
	end function

	begin public function this.getNext() to (LinkedList return)
		# this function is "pure," and we can tell because it doesn't take any of the same
		# arguments as it outputs
		if next isa LinkedList
			return := next asa LinkedList # asa is the casting operator
				# This gets the LinkedList out of the tagged union Link we made above
		else
			return := EndOfListException.raise(here) # return an exception instead
				# which we can do because we inherit from Result
		end if
	end function

	begin public function this.pop to this, (LinkedList return)
		# Example of a function which modifies "this" and also returns extra data
		return := LinkedList.new(initialData=data)
		this <- this.getNext()
	end function

	begin public function this.length to (Natural return)
		if next isa LinkedList
			return := next.length + 1
			# Once all of the named returned data are assigned we can stop executing
		else
			return := 0
		end if
	end function
end class
